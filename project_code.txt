///////////////////////////
// .gitignore
///////////////////////////

out
dist
node_modules
.vscode-test/
*.vsix

///////////////////////////
// launchvs.bat
///////////////////////////

code .

///////////////////////////
// LICENSE.txt
///////////////////////////

MIT License

Copyright (c) 2025 Limacha

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


///////////////////////////
// package.json
///////////////////////////

{
    "name": "arflakatool",
    "displayName": "Arflaka Tool",
    "description": "tool to help for coding",
    "version": "0.1.0",
    "publisher": "Arflaka-Limacha",
    "license": "see license in LICENSE.txt",
    "engines": {
        "vscode": "^1.102.0"
    },
    "categories": [
        "Other"
    ],
    "activationEvents": [
        "onStartupFinished",
        "onDidSaveTextDocument"
    ],
    "main": "./out/extension.js",
    "contributes": {
        "commands": [
            {
                "command": "akTool.createstruct",
                "title": "akTool.createstruct"
            },
            {
                "command": "akTool.createExample",
                "title": "akTool.createExample"
            },
            {
                "command": "akTool.generateWrokspace",
                "title": "akTool.generateWrokspace"
            }
        ]
    },
    "scripts": {
        "vscode:prepublish": "npm run compile",
        "compile": "tsc -p ./",
        "watch": "tsc -watch -p ./",
        "pretest": "npm run compile && npm run lint",
        "lint": "eslint src",
        "test": "vscode-test",
        "publish": "npm run vscode:prepublish && vsce publish",
        "patch": "npm run vscode:prepublish && vsce publish patch"
    },
    "devDependencies": {
        "@types/node": "^24.0.15",
        "@types/vscode": "^1.102.0",
        "typescript": "^5.8.3"
    },
    "repository": {
        "type": "git",
        "url": "git+https://github.com/Limacha/arflakatool.git"
    },
    "keywords": [],
    "author": "Arflaka-Limacha",
    "bugs": {
        "url": "https://github.com/Limacha/arflakatool/issues"
    },
    "homepage": "https://github.com/Limacha/arflakatool#readme"
}

///////////////////////////
// README.md
///////////////////////////

fait pour avoir plein de fonctionaliter en plus

///////////////////////////
// tsconfig.json
///////////////////////////

{
    "compilerOptions": {
        "module": "Node16",
        "target": "ES2022",
        "outDir": "./out",
        "rootDir": "./src",
        "sourceMap": true,
        "strict": true,
        "esModuleInterop": true
    },
    "exclude": [
        "node_modules",
        ".vscode-test"
    ]
}

///////////////////////////
// .vscode
///////////////////////////



///////////////////////////
// .vscode\extensions.json
///////////////////////////

{
	// See http://go.microsoft.com/fwlink/?LinkId=827846
	// for the documentation about the extensions.json format
	"recommendations": [
		"dbaeumer.vscode-eslint",
		"ms-vscode.extension-test-runner"
	]
}


///////////////////////////
// .vscode\launch.json
///////////////////////////

// A launch configuration that compiles the extension and then opens it inside a new window
// Use IntelliSense to learn about possible attributes.
// Hover to view descriptions of existing attributes.
// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
{
	"version": "0.2.0",
	"configurations": [
		{
			"name": "Run Extension",
			"type": "extensionHost",
			"request": "launch",
			"args": [
				"--extensionDevelopmentPath=${workspaceFolder}"
			],
			"outFiles": [
				"${workspaceFolder}/out/**/*.js"
			],
			"preLaunchTask": "${defaultBuildTask}"
		}
	]
}


///////////////////////////
// .vscode\settings.json
///////////////////////////

// Place your settings in this file to overwrite default and user settings.
{
	"files.exclude": {
		"out": false // set this to true to hide the "out" folder with the compiled JS files
	},
	"search.exclude": {
		"out": true // set this to false to include "out" folder in search results
	},
	// Turn off tsc task auto detection since we have the necessary tasks as npm scripts
	"typescript.tsc.autoDetect": "off"
}


///////////////////////////
// .vscode\tasks.json
///////////////////////////

// See https://go.microsoft.com/fwlink/?LinkId=733558
// for the documentation about the tasks.json format
{
	"version": "2.0.0",
	"tasks": [
		{
			"type": "npm",
			"script": "watch",
			"problemMatcher": "$tsc-watch",
			"isBackground": true,
			"presentation": {
				"reveal": "never"
			},
			"group": {
				"kind": "build",
				"isDefault": true
			}
		}
	]
}


///////////////////////////
// src
///////////////////////////



///////////////////////////
// src\config.ts
///////////////////////////

import path from 'path';
import * as fs from 'fs';
import { error } from './log';

//#region root path
let rootPath = "";
let onRootPathChangeCallbacks: ((newPath: string) => void)[] = [];

export function getRootPath() {
    return rootPath;
}

export function setRootPath(newPath: string) {
    if (rootPath !== newPath) {
        rootPath = newPath;

        // Appeler tous les callbacks
        for (const cb of onRootPathChangeCallbacks) {
            cb(newPath);
        }
    }
}

// Permet √† d'autres modules de r√©agir au changement
export function onRootPathChange(callback: (newPath: string) => void) {
    onRootPathChangeCallbacks.push(callback);
}

//#endregion
//#region config path

const configFileName = "akTool.config.json"
let configPath = "./akTool.config.json";
let onConfigPathChangeCallbacks: ((newPath: string) => void)[] = [];

export function getConfigPath() {
    return configPath;
}

function setConfigPath(newPath: string) {
    if (configPath !== newPath) {
        configPath = newPath;

        // Appeler tous les callbacks
        for (const cb of onConfigPathChangeCallbacks) {
            cb(newPath);
        }
    }
}

onRootPathChange(rootPath => setConfigPath(path.join(rootPath, configFileName)))

// Permet √† d'autres modules de r√©agir au changement
export function onConfigPathChange(callback: (newPath: string) => void) {
    onConfigPathChangeCallbacks.push(callback);
}

/**
 * permet d'obtenir le contenu du fichier config
 * @returns le contenu du fichier config
 */
export function getConfigContent(): any {
    try {
        const configContent = fs.readFileSync(getConfigPath(), 'utf-8');
        return JSON.parse(configContent);
    } catch {
        error(`Fichier de config '${getConfigPath()}' introuvable.`);
        return {}; //renvoie aucun filter
    }
}
//#endregion

///////////////////////////
// src\copySaveAndEdit.ts
///////////////////////////

import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { getRootPath, getConfigPath, getConfigContent } from './config';
import { validate } from './validation';
import { exampleMap } from './creatorExampleFile';
import { log } from './log';

export interface CopyRule {
    source: string; // nom du fichier √† surveiller (ex: "script.js")
    destination: string; // chemin relatif de destination (ex: "copie/script_copy.js")
    injection: {
        text: string; // texte √† injecter
        position: number; // position de l'injection
    }[];
}

// export function isCopyRule(obj: any): obj is CopyRule {
//     return obj &&
//         typeof obj.source === 'string' &&
//         typeof obj.destination === 'string' &&
//         typeof obj.injection === 'string' &&
//         (obj.position === 'start' || obj.position === 'end');
// }

/**
 * 
 * @returns le filtre sous format StructureConfig
 */
async function loadConfig(): Promise<CopyRule[]> {

    //verifie le type des entrees
    const config: CopyRule[] = validate(getConfigContent()?.CopyRule, exampleMap["CopyRule"]);
    log(getConfigPath());
    log(config);
    return config;
}

export async function copySaveAndEdit(document: vscode.TextDocument) {

    let rules: CopyRule[] = await loadConfig();

    if (rules === null || rules?.length === 0) {
        vscode.window.showWarningMessage(`Fichier de config '${getConfigPath()}' invalide.`);
    }

    const filePath = path.relative(getRootPath(), document.uri.fsPath).replace(/\\/g, '/');

    const matchingRules = rules.filter(rule => rule.source === filePath);

    if (matchingRules.length === 0) return;

    const originalContent = document.getText().split('\n');

    matchingRules.forEach(rule => {
        var newContent = originalContent.slice();

        //injecte tout les elements
        rule.injection.forEach(injection => {
            const position = Math.round(injection.position); //arondit pour pas avoir de float
            //enfonction de si on part de la fin ou du debut
            if (position < 0) {
                //eviter d'ajouter en -5
                if (newContent.length + 1 + position >= 0) {
                    newContent.splice(newContent.length + 1 + position, 0, injection.text);
                }
                else {
                    newContent.splice(0, 0, injection.text);
                }
            }
            else if (position > 0) {
                newContent.splice(position - 1, 0, injection.text);
            }
        });

        const destPath = path.join(getRootPath(), rule.destination); //chemin du fichier
        const destDir = path.dirname(destPath); //chemin du dossier

        // Cr√©e le dossier s'il n'existe pas
        try {
            fs.mkdirSync(destDir, { recursive: true });
        } catch (mkdirErr) {
            vscode.window.showErrorMessage(`Erreur cr√©ation du dossier ${destDir} : ${mkdirErr}`);
            return;
        }

        //ecrit dans le fichier
        fs.writeFile(destPath, newContent.join("\n"), err => {
            if (err) {
                vscode.window.showErrorMessage(`Erreur √©criture ${rule.destination} : ${err.message}`);
            } else {
                vscode.window.showInformationMessage(`Copi√© ${rule.source} ‚Üí ${rule.destination}`);
            }
        });
    });
}

///////////////////////////
// src\creatorExampleFile.ts
///////////////////////////

import * as vscode from 'vscode';
import * as fs from 'fs';
import { log, warn, error } from './log';
import { getConfigPath } from './config';
import { StructureConfig } from './structGenerator';
import { CopyRule } from './copySaveAndEdit';


/* #region example */
const exampleStructureConfig: StructureConfig = {
    "excludeFolders": [
        "test42\test",
        "test42\\test",
        "test42/test"
    ],
    "excludeExtensions": [
        ".txt"
    ],
    "excludeFiles": [
        "project_structure.txt",
        "akTool.config.json",
        "origin/script.js"
    ],
    "excludeName": [
        "*amp*",
        "exam*",
        "*m**e*",
        "example"
    ],
    "excludeCode": {
        "folders": [
            "example"
        ],
        "extensions": [
            ".js"
        ],
        "files": [
            "example.txt",
            "package-lock.json"
        ],
        "name": [
            "*amp*",
            "exam*",
            "*m**e*",
            "example"
        ]
    }
};

const exampleCopyRule: CopyRule[] =
    [
        {
            source: 'script.js',
            destination: 'copie/script_copy.js',
            injection: [{ text: "//end", position: -1 }, { text: "//start", position: 1 }, { text: "//pas ajouter", position: 0 }, { text: "//ligne 15", position: 15 }, { text: "//ligne 5 depuis la fin", position: -5 }]
        }
    ];

export const exampleMap: Record<string, any> = {
    StructureConfig: exampleStructureConfig,
    CopyRule: exampleCopyRule,
    // ajouter d'autres exemples ici si besoin
};
/* #endregion */

export async function createExampleFile(types: string[]) {
    log(types);
    // Objet final, une seule entr√©e par type (nom de type => objet)
    const example: Record<string, any> = {};

    types.forEach((typeName) => {
        //si le type a un example
        if (exampleMap[typeName]) {
            //ajoute l'example
            example[typeName] = exampleMap[typeName];
        } else {
            warn(`Aucun exemple trouv√© pour le type "${typeName}"`);
        }
    });


    try {
        const path = getConfigPath();
        log(example);
        fs.writeFileSync(path, JSON.stringify(example, null, 2), 'utf-8');
        vscode.window.showInformationMessage(`Fichier ${path} cr√©√©.`);

        //ouvre le document
        const doc = await vscode.workspace.openTextDocument(path);
        vscode.window.showTextDocument(doc);

    } catch (e: any) {
        vscode.window.showErrorMessage("Erreur √©criture du fichier : " + e.message);
    }
}

///////////////////////////
// src\extension.ts
///////////////////////////

import * as vscode from 'vscode';
import { generateStructure } from './structGenerator';
import { exampleMap, createExampleFile } from './creatorExampleFile';
import { outputChannel, logChannel, log } from './log';
import { getRootPath, setRootPath } from './config';
import { copySaveAndEdit } from './copySaveAndEdit';
import { generateWorkspaceFromStructure } from './generateWorkspace';
import { pathExists } from './function';

export function activate(context: vscode.ExtensionContext) {
    verifWorkspace();
    logChannel("Extension akTool activ√©e!");
    log("Extension akTool activ√©e!");

    const generateStruct = vscode.commands.registerCommand('akTool.createstruct', async () => {
        log('akTool.createstruct');
        if (!verifWorkspace()) {
            vscode.window.showErrorMessage("Aucun dossier ouvert.");
            return;
        }

        const option = await vscode.window.showQuickPick([
            'Code dans le meme fichier',
            'Code dans un autre fichier',
            'Structure seule'
        ], {
            placeHolder: 'Choisissez une option'
        });

        if (!option) return;

        generateStructure(option);
    });
    context.subscriptions.push(generateStruct);

    const generateWorkspaceFromStruct = vscode.commands.registerCommand('akTool.generateWrokspace', async () => {
        log('akTool.generateWrokspace');
        const options = await vscode.window.showQuickPick([
            "code", "structure", "from", "to", "2 files"
        ], {
            placeHolder: 'Choisissez les parametres',
            canPickMany: true
        });

        if (!options || options.length === 0) return;

        let from: string | undefined = getRootPath() + "\\project_structure.txt";
        let fromCode: string | undefined = getRootPath() + "\\project_code.txt";
        let to: string | undefined = getRootPath();
        log(from, fromCode, to);
        if (options.includes("from")) {
            if (options.includes("2 files")) {
                do {
                    from = await vscode.window.showInputBox({
                        prompt: 'Chemin vers le fichier contenant la structure',
                        placeHolder: 'path',
                        ignoreFocusOut: true,
                    });
                } while (!from);
                do {
                    fromCode = await vscode.window.showInputBox({
                        prompt: 'Chemin vers le fichier contenant le code',
                        placeHolder: 'path',
                        ignoreFocusOut: true,
                    });
                } while (!fromCode);
            }
            else {

                do {
                    from = await vscode.window.showInputBox({
                        prompt: 'Chemin vers le fichier contenant la structure',
                        placeHolder: 'path',
                        ignoreFocusOut: true,
                    });
                } while (!from);
            }
        }
        if (options.includes("to")) {
            do {
                to = await vscode.window.showInputBox({
                    prompt: 'Chemin vers le dossier ou sera genere le contenu',
                    placeHolder: 'path',
                    ignoreFocusOut: true,
                });
            } while (!to);
        }

        generateWorkspaceFromStructure(from, to, options.includes("structure"), options.includes("code"), (options.includes("2 files")) ? fromCode : "");
    });
    context.subscriptions.push(generateWorkspaceFromStruct);

    // Commande pour cr√©er le fichier JSON exemple
    const createJsonFile = vscode.commands.registerCommand('akTool.createExample', async () => {
        log('akTool.createExample');
        if (!verifWorkspace()) {
            vscode.window.showErrorMessage("Aucun dossier ouvert.");
            return;
        }

        const exampleTypes: string[] = Object.keys(exampleMap);

        const options = await vscode.window.showQuickPick(exampleTypes, {
            placeHolder: 'Choisissez les examples',
            canPickMany: true
        });
        createExampleFile(options || []);
    });
    context.subscriptions.push(createJsonFile);

    vscode.workspace.onDidSaveTextDocument(document => {
        log('onDidSaveTextDocument', document);
        if (!verifWorkspace()) {
            vscode.window.showErrorMessage("Aucun dossier ouvert.");
            return;
        }
        copySaveAndEdit(document);
    });

    vscode.workspace.onDidChangeWorkspaceFolders(event => {
        log('onDidChangeWorkspaceFolders', event);
        if (event.added.length > 0) {
            log(`üìÅ Dossier(s) ajout√©(s) : ${event.added.map(f => f.name).join(', ')}`);
        }

        if (event.removed.length > 0) {
            log(`‚ùå Dossier(s) supprim√©(s) : ${event.removed.map(f => f.name).join(', ')}`);
        }

        verifWorkspace();
    });
}

export function deactivate() {
    outputChannel.appendLine("Extension d√©sactiv√©e.");
    outputChannel.dispose();
}



/**
 * verifier si on se trouve dans un workspace
 * @returns si dans un workspace
 */
function verifWorkspace(): boolean {
    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders) {
        setRootPath("");
        return false;
    }
    setRootPath(workspaceFolders[0].uri.fsPath);
    return true;
}

///////////////////////////
// src\function.ts
///////////////////////////

import * as fs from 'fs';
import * as fsPromise from 'fs/promises';
import * as path from 'path';
import { getRootPath } from './config';
import { error, log } from './log';

/**
 * enlave tout les caractere speciale ex: '\n' -> "\\n"
 * @param str la chaine de caractere
 * @returns un chane sans caractere special
 */
export function escapeSpecialChars(str: string): string {
    return str.replace(/[\0-\x1F\'""]/g, (c) => {
        switch (c) {
            case '\0': return '\\0';
            case '\n': return '\\n';
            case '\r': return '\\r';
            case '\t': return '\\t';
            case '\b': return '\\b';
            case '\f': return '\\f';
            case '\v': return '\\v';
            case '\'': return '\\\'';
            case '\"': return '\\"';
            default: {
                // Pour les autres caract√®res de contr√¥le (codes < 32) non list√©s
                const code = c.charCodeAt(0);
                if (code < 32) {
                    return '\\x' + code.toString(16).padStart(2, '0');
                }
                return c;
            }
        }
    });
}

/**
 * stantardise un chemin fournit
 * @param path le chemin a standardiser
 * @returns path\\file
 */
export function standarPath(path: string) {
    return escapeSpecialChars(path).replace(/\//g, '\\');
}

/**
 * verifier si le chemin fournit donne sur un dossier
 * @param chemin le chemin a verifier
 * @returns si le chemin donne sur un dossier
 */
export function isDir(chemin: string): boolean {
    try {
        const stat = fs.statSync(chemin);
        return stat.isDirectory();
    } catch (err) {
        // Le chemin n'existe pas ou une erreur s'est produite
        return false;
    }
}


/**
 * verifie si le chemin fournit existe
 * @param filePath chemin
 * @returns si il existe ou pas
 */
export async function pathExists(filePath: string): Promise<boolean> {
    try {
        if (!path.isAbsolute(filePath)) if (getRootPath() != "") filePath = path.join(getRootPath(), filePath);
        // V√©rifie si le fichier/dossier est accessible
        await fsPromise.access(filePath, fs.constants.F_OK);
        return true;
    } catch {
        return false;
    }
}

/**
 * lit le contenu d'un fichier
 * @param path le chemin du fichier
 * @returns le contenu
 */
export function readFileContent(path: string): string {
    try {
        const configContent = fs.readFileSync(path, 'utf-8');
        return configContent;
    } catch {
        error(`Fichier '${path}' introuvable.`);
        return ""; //renvoie aucun filter
    }
}

/**
 * cree un dossier
 * @param dirPath le chemin du dossier
 */
export async function createDir(dirPath: string): Promise<void> {
    const resolvedPath = path.resolve(dirPath);
    await fsPromise.mkdir(resolvedPath, { recursive: true });
}

/**
 * cree un fichier
 * @param filePath le chemin du fichier
 * @param content le contenu du fichier
 */
export async function createFile(filePath: string, content: string = ''): Promise<void> {
    const resolvedPath = path.resolve(filePath);
    const dir = path.dirname(resolvedPath);

    // S'assurer que le dossier existe
    await fsPromise.mkdir(dir, { recursive: true });

    // Cr√©er le fichier avec le contenu
    await fsPromise.writeFile(resolvedPath, content, { encoding: 'utf-8' });
}

export async function clearDirectory(dirPath: string): Promise<void> {
    try {
        const resolvedPath = path.resolve(dirPath);

        // V√©rifie si le dossier existe
        if (!(await pathExists(dirPath)) && !(await isDir(dirPath))) {
            return;
        }

        // Lire les fichiers et dossiers √† l'int√©rieur
        const files = await fsPromise.readdir(resolvedPath);

        // Supprimer chaque √©l√©ment √† l'int√©rieur
        for (const file of files) {
            const fullPath = path.join(resolvedPath, file);
            const fileStat = await fsPromise.stat(fullPath);

            if (fileStat.isDirectory()) {
                // Supprimer r√©cursivement le sous-dossier
                await fsPromise.rm(fullPath, { recursive: true, force: true });
            } else {
                await fsPromise.unlink(fullPath);
            }
        }
    } catch (err: any) {
        //error(err)
        throw err;
    }
}


export function createFullPath(filePath: string) {
    if (!path.isAbsolute(filePath)) filePath = (getRootPath() != "") ? path.join(getRootPath(), filePath) : "c:\\" + filePath;
    return filePath;
}

///////////////////////////
// src\generateWorkspace.ts
///////////////////////////

import * as fs from 'fs';
import * as path from 'path';
import * as vscode from 'vscode';
import { logChannel, log, warn, error } from './log';
import { getRootPath } from './config';
import { clearDirectory, createDir, createFile, escapeSpecialChars, pathExists, readFileContent, standarPath, createFullPath } from './function';

export async function generateWorkspaceFromStructure(from: string, to: string, structure: boolean, code: boolean, fromCode: string = "") {
    let struct: string[] = [];
    let files: Map<string, string> = new Map;
    let allTask: number = 0;

    from = createFullPath(standarPath(from));
    if (fromCode != "") fromCode = createFullPath(standarPath(fromCode));
    to = createFullPath(standarPath(to));

    if (!await pathExists(from)) {
        vscode.window.showErrorMessage(`le chemin from n'existe pas: ${from}`)
        return;
    }

    if (fromCode != "" && !await pathExists(fromCode)) {
        vscode.window.showErrorMessage(`le chemin fromCode n'existe pas: ${fromCode}`)
        return;
    }

    if (!await pathExists(to)) {
        vscode.window.showErrorMessage(`le chemin to n'existe pas: ${to}`)
        return;
    }

    if (structure) {
        struct = readFileContent(from).split("\n").filter(ligne => { return (ligne.startsWith("‚îú") || ligne.startsWith("‚îÇ")) && ligne.split("‚îú").length === 2 });
        log(struct);
        allTask += struct.length;
    }

    if (code) {
        const content: string[] = readFileContent((fromCode != "") ? fromCode : from).split("///////////////////////////\n");
        for (let index = 1; index < content.length - 1; index += 2) {
            //log(`i=${index} m=${content.length + 1}`);
            files.set(content[index].slice(3), content[index + 1]);
        }
        log("files", files);
        allTask += files.size;
    }
    //log(allTask);
    vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: "generation en cours...",
        cancellable: false
    }, (progress) => {
        let lastProgress: number = 0;
        let taskDone: number = 0;
        let notice: boolean = true;

        /**
         * definit la valeur de la barre de chargement
         * @param value valeur de chargement de 0-100
         * @param message message qui sera afficher a la place de x%
         */
        const report = (value: number = lastProgress, message: string = "") => {
            const increment = value - lastProgress;
            progress.report({ increment, message: (message != "") ? message : `${value}%` });
            lastProgress = value;
        };
        /*return new Promise<void>((resolve) => {
            let i = 0;
            let interval = setInterval(() => {
                i += 10;
                progress.report({ increment: 10, message: `${i}%` });

                if (i >= 100) {
                    clearInterval(interval);
                    resolve();
                }
            }, 300); // incr√©mente toutes les 300ms
        });*/
        return new Promise<void>(async (resolve) => {
            try {
                let previusDir = to;
                let elemMarker = 0;
                let previusElemMarker = 0;
                for (let iLigne = 0; iLigne < struct.length; iLigne++) {
                    const ligne = struct[iLigne];

                    //verification et adaptation du chemin
                    if (ligne.charAt(ligne.indexOf("‚îú") + 1) === "D") {
                        elemMarker = ligne.indexOf("‚îú");
                        if (elemMarker === 0) { previusDir = to; }//si debut alors fichier a la racine
                        else if (elemMarker === previusElemMarker) { previusDir = previusDir.slice(undefined, previusDir.lastIndexOf("\\")); } //si meme niveau alors suprime le dernier dir
                        else if (elemMarker < previusElemMarker) { //si inferieur supprime la differance de sous dossier
                            const subNum = ligne.split("‚îÇ").length;
                            const previusSubNum = struct[iLigne - 1].split("‚îÇ").length;
                            for (let iSup = 0; iSup < previusSubNum - subNum; iSup++) {
                                previusDir = previusDir.slice(undefined, previusDir.lastIndexOf("\\"));
                            }
                        }
                        previusElemMarker = elemMarker;
                    }

                    //creez le chemin de l'element actuel
                    let path = previusDir + "\\" + ligne.slice(ligne.indexOf("‚îú") + 4);
                    report(undefined, path);
                    log(path);
                    if (ligne.charAt(ligne.indexOf("‚îú") + 1) === "D") {
                        previusDir = path;
                        if (notice && await pathExists(path)) {
                            const answer = await vscode.window.showQuickPick(["confirmer", "annuller", "pour tous"], { placeHolder: `le contenu du dossier ${path} sera suprimer`, canPickMany: true });
                            if (answer?.includes("annuller")) {
                                if (answer?.includes("pour tous")) {
                                    resolve();
                                    return;
                                } else {
                                    continue;
                                }
                            }
                            else if (answer?.includes("confirmer") && answer.includes("pour tous")) {
                                notice = false;
                            }
                        }
                        await clearDirectory(path);
                        await createDir(path);
                    }
                    else {
                        if (notice && await pathExists(path)) {
                            const answer = await vscode.window.showQuickPick(["confirmer", "annuller", "pour tous"], { placeHolder: `le contenu du fichier ${path} sera suprimer`, canPickMany: true });
                            if (answer?.includes("annuller")) {
                                if (answer?.includes("pour tous")) {
                                    resolve();
                                    return;
                                } else {
                                    continue;
                                }
                            }
                            else if (answer?.includes("confirmer") && answer.includes("pour tous")) {
                                notice = false;
                            }
                        }
                        await createFile(path);
                    }
                    taskDone++;
                    report(taskDone / allTask * 100, "V " + path);
                }

                resolve();
            } catch (err) {
                resolve();
                vscode.window.showErrorMessage("une erreur est survenu: " + err);
                error(err);
            }
        })
    }).then(() => {
        vscode.window.showInformationMessage("structure generer");
    });
}

///////////////////////////
// src\log.ts
///////////////////////////

import * as vscode from 'vscode';

const prefix = "--akTool--> "

export const outputChannel = vscode.window.createOutputChannel("akTool");

export function logChannel(...messages: string[]) {
    for (const msg of messages) {
        outputChannel.append(prefix);
        outputChannel.appendLine(msg);
    }
    outputChannel.show(true);
}

export function log(...messages: any[]) {
    for (const msg of messages) {
        console.log(prefix, msg);
    }
}

export function warn(...messages: any[]) {
    for (const msg of messages) {
        console.warn(prefix, msg);
    }
}

export function error(...messages: any[]) {
    for (const msg of messages) {
        console.error(prefix, msg);
    }
}


///////////////////////////
// src\structGenerator.ts
///////////////////////////

import * as fs from 'fs';
import * as path from 'path';
import * as vscode from 'vscode';
import { logChannel, log } from './log';
import { getConfigContent, getConfigPath, getRootPath } from './config'
import { validate } from './validation';
import { exampleMap } from './creatorExampleFile';
import { escapeSpecialChars, isDir, standarPath } from './function';

/**
 * type du fichier config
 */
export interface StructureConfig {
    excludeFolders?: string[];
    excludeExtensions?: string[];
    excludeFiles?: string[];
    excludeName?: string[];
    excludeCode?: {
        folders?: string[];
        extensions?: string[];
        files?: string[];
        name?: string[];
    };
}

// export function isStructureConfig(obj: any): obj is StructureConfig {
//     return obj && (
//         'excludeFolders' in obj ||
//         'excludeExtensions' in obj ||
//         'excludeFiles' in obj ||
//         'excludeNamePatterns' in obj
//     );
// }



/**
 * charge la config de la structure
 * @returns le filtre sous format StructureConfig
 */
async function loadConfig(): Promise<StructureConfig> {

    //verifie le type des entrees
    const config: StructureConfig = validate(getConfigContent()?.StructureConfig, exampleMap["StructureConfig"]);
    normalizeConfigPaths(config);
    if (config &&
        config.excludeFolders === null &&
        config.excludeExtensions === null &&
        config.excludeFiles === null &&
        config.excludeName === null && (
            (
                config.excludeCode != null &&
                config.excludeCode.folders === null &&
                config.excludeCode.extensions === null &&
                config.excludeCode.files === null &&
                config.excludeCode.name === null
            ) ||
            config.excludeCode === null
        )
    ) {

        vscode.window.showWarningMessage(`Fichier de config '${getConfigPath()}' invalide.`);
    }
    return config;
}

function normalizeConfigPaths(config: StructureConfig): void {
    const normalizeArray = (arr?: string[] | null): string[] =>
        Array.isArray(arr) ? arr.map(s => standarPath(s)) : arr ?? [];

    config.excludeFolders = normalizeArray(config.excludeFolders);
    config.excludeExtensions = normalizeArray(config.excludeExtensions);
    config.excludeFiles = normalizeArray(config.excludeFiles);
    config.excludeName = normalizeArray(config.excludeName);

    if (config.excludeCode) {
        config.excludeCode.folders = normalizeArray(config.excludeCode.folders);
        config.excludeCode.extensions = normalizeArray(config.excludeCode.extensions);
        config.excludeCode.files = normalizeArray(config.excludeCode.files);
        config.excludeCode.name = normalizeArray(config.excludeCode.name);
    }
    //log(config);
}

/**
 * verifier si le patern est dans le nom du fichier
 * @param filename - nom du fichier
 * @param pattern - le patern a verifier
 * @returns si le patern est dedans ou pas
 */
function matchesPattern(filename: string, pattern: string): boolean {
    // *text*
    if (pattern.startsWith("*") && pattern.endsWith("*") && pattern.split("*").length === 3) {
        const inner = pattern.slice(1, -1);
        return filename.includes(inner);
    }

    // *text
    if (pattern.startsWith("*") && !pattern.endsWith("*")) {
        const suffix = pattern.slice(1);
        return filename.endsWith(suffix);
    }

    // text*
    if (!pattern.startsWith("*") && pattern.endsWith("*")) {
        const prefix = pattern.slice(0, -1);
        return filename.startsWith(prefix);
    }

    //si quelque part
    if (pattern.includes("*")) {
        const parts = pattern.split("*");
        // logChannel(parts.toString());
        // log(parts.toString());
        let startIndex = 0;

        // Si le pattern ne commence pas par *, v√©rifier le pr√©fixe
        if (parts[0] !== "") {
            if (!filename.startsWith(parts[0])) return false;
            startIndex = parts[0].length;
        }

        // Si le pattern ne finit pas par *, v√©rifier le suffixe
        if (parts[parts.length - 1] !== "") {
            const suffix = parts[parts.length - 1];
            if (!filename.endsWith(suffix)) return false;
        }

        // Chercher les morceaux interm√©diaires dans l'ordre
        for (let i = 1; i < parts.length - 1; i++) {
            const part = parts[i];
            if (part === "") continue; // plusieurs * cons√©cutifs

            const index = filename.indexOf(part, startIndex);
            if (index === -1) return false;
            startIndex = index + part.length;
        }

        return true;
    }

    //si nom exact
    return filename === pattern;
}


/**
 * verifie si l'element est a exclure
 * @param fullPath - chemin vers le fichier/dossier
 * @param rootPath - la racine
 * @param config - la config de se qu'il faut exclure
 * @returns si exclu ou pas
 */
function isExcludFromStruct(fullPath: string, rootPath: string, config: StructureConfig): boolean {
    const relativePath = path.relative(rootPath, fullPath); //chemin relatif
    const ext = path.extname(fullPath); //extantion du fichier
    const baseName = path.basename(fullPath); //le nom du fichier
    //log("-----", relativePath, ext, baseName, "-----");

    if (isDir(fullPath)) {
        //si des dossier son exclu
        if (config.excludeFolders) {
            if (config.excludeFolders.includes(relativePath)) {
                return true;
            }
        }
        return false;
    }

    if (!baseName.includes(".")) {
        return false;
    }

    //si le fichier est exclu
    if (config.excludeFiles) {
        if (config.excludeFiles.includes(relativePath)) {
            return true;
        }
    }

    //si l'extention est exlu
    if (config.excludeExtensions) {
        if (config.excludeExtensions.includes(ext)) {
            return true;
        }
    }

    //si le patern est dedans
    if (config.excludeName) {
        //pour tout les paterns
        for (const pattern of config.excludeName) {
            //verifie si dedans
            if (matchesPattern(baseName, pattern)) {
                return true;
            }
        }
    }

    return false;
}

/**
 * verifie si l'element est a exclure
 * @param relativePath - chemin relatif a la racine
 * @param config - la config de se qu'il faut exclure
 * @returns si exclu ou pas
 */
function isExcludFromCode(fullPath: string, rootPath: string, config: StructureConfig): boolean {
    const relativePath = path.relative(rootPath, fullPath);
    const ext = path.extname(fullPath); //extantion du fichier
    const dirParts = relativePath.split(path.sep); //chaque directory
    const baseName = path.basename(fullPath); //le nom du fichier

    if (isDir(fullPath)) {
        return true;
    }

    //si des dossier son exclu
    if (config.excludeCode?.folders) {
        //! car sur pas null
        if (dirParts.some(folder => config.excludeFolders!.includes(folder))) {
            return true;
        }
    }

    if (!baseName.includes(".")) {
        return false;
    }

    //si l'extention est exlu
    if (config.excludeCode?.extensions) {
        if (config.excludeCode.extensions.includes(ext)) {
            return true;
        }
    }

    //si le fichier est exclu
    if (config.excludeCode?.files) {
        if (config.excludeCode.files.includes(relativePath)) {
            return true;
        }
    }

    //si le patern est dedans
    if (config.excludeCode?.name) {
        //pour tout les paterns
        for (const pattern of config.excludeCode.name) {
            //verifie si dedans
            if (matchesPattern(baseName, pattern)) {
                return true;
            }
        }
    }

    return false;
}

/**
 * lit le contenu d'un fichier
 * @param filePath - le chemin du fichier a lire
 * @returns le contenu
 */
async function readFileContent(filePath: string): Promise<string> {
    try {
        return await fs.promises.readFile(filePath, 'utf8');
    } catch {
        return '';
    }
}

/**
 * genere une ligne formater pour la structure du project
 * @param filePath - le chemin du fichier
 * @param root - la racine du project
 * @param withComment - si on ajoute les commentaires
 * @returns une ligne avec les indentations et le nom du fichier
 */
function formatTreeLine(filePath: string, root: string): string {
    const relative = path.relative(root, filePath); //chemin depuis la racine
    const parts = relative.split(path.sep); //separe chaque partie du chemin
    const indent = '‚îÇ   '.repeat(parts.length - 1); //indentation
    const fileName = parts[parts.length - 1]; //nom du fichier

    return `${indent}‚îú${(isDir(filePath)) ? "D" : "F"}‚îÄ ${fileName}`;
}

/**
 * fait une liste de tout les fichier trouver dans le dossier
 * @param dir - le chemin du dossier dans le quel verifier
 * @param allFiles - une liste de tout les fichier d√©ja trouver
 * @returns une liste de tout les fichier trouver dans le dossier et sous-dossier
 */
async function walk(dir: string, rootPath: string, config: StructureConfig, allFiles: string[] = []): Promise<string[]> {
    const entries = await fs.promises.readdir(dir, { withFileTypes: true }); //retourne tout les elemants dans le dossier
    var dirs: string[] = [];
    for (const entry of entries) {
        const fullPath = path.join(entry.parentPath, entry.name); //fait le chemin complet de l'element
        //verifie si il est exclu ou pas
        if (!isExcludFromStruct(fullPath, rootPath, config)) {
            if (entry.isDirectory()) {
                dirs.push(fullPath)
            } else {
                allFiles.push(fullPath); //ajoute le fichier a la liste
            }
        }
    }
    //refait pour les sous dossier
    while (dirs.length != 0) {
        //log("dirs", dirs);
        allFiles.push(dirs[0])
        await walk(dirs[0], rootPath, config, allFiles); //refait un parcour
        dirs.shift(); //retire le dossier de la liste
    }
    return allFiles;
}

export async function generateStructure(mode: string) {
    const config = await loadConfig();
    const files = await walk(getRootPath(), getRootPath(), config); //liste de tout les fichiers valides
    const outputLines: string[] = []; //contient le contenu du fichier final ligne par ligne
    const separateFiles: string[] = []; //contenu dans un fichier separer
    /*for (const file of files) {
        outputLines.push(file); //ajoute la ligne
    }*/
    outputLines.push('=== Structure du projet ===\n');

    for (const file of files) {
        const line = formatTreeLine(file, getRootPath()); //cree un ligne formater
        outputLines.push(line); //ajoute la ligne
    }

    outputLines.push('\n');

    //log(files);

    if (mode.includes('code') || mode.includes('Code')) {
        for (const file of files) {
            const relativePath = path.relative(getRootPath(), file);
            if (!isExcludFromCode(file, getRootPath(), config)) {
                const content = await readFileContent(file); //le contenu du fichier
                const title =
                    "///////////////////////////\n" +
                    `// ${relativePath}\n` +
                    "///////////////////////////"; //le titre du fichier

                const block = `${title}\n${content}\n`; //un block avec le titre et le contenu

                if (mode.includes('meme fichier') || mode.includes('un fichier')) {
                    outputLines.push(block); //ajoute le block au fichier
                } else {
                    separateFiles.push(block); //ajoute le block dans un fichier separer
                }
            }
        }
    }

    const uri = vscode.Uri.file(path.join(getRootPath(), 'project_structure.txt'));
    await fs.promises.writeFile(uri.fsPath, outputLines.join('\n'), 'utf8');

    if (separateFiles.length != 0) {
        const filepath = vscode.Uri.file(path.join(getRootPath(), 'project_code.txt'));
        await fs.promises.writeFile(filepath.fsPath, separateFiles.join('\n'), 'utf8');
    }

    vscode.window.showInformationMessage("Structure du projet g√©n√©r√©e !");
}

///////////////////////////
// src\validation.ts
///////////////////////////

import { log } from './log';
type SchemaType =
    | 'string'
    | 'number'
    | 'boolean'
    | 'undefined'
    | [SchemaType]
    | [Schema];

type Schema = {
    [key: string]: SchemaType | Schema; // supporte objets imbriqu√©s ou tableaux d'objets
};


/**
 * detect le type de l'object et renvoie son equivalent dans un schema
 * @param value la valeur de la quel on veut obtenir le type
 * @returns un type ou un schema de la valeur
 */
function detectType(value: any): SchemaType | Schema {
    if (typeof value === 'string') return 'string'; //si un string
    if (typeof value === 'number') return 'number'; //si un nombre
    if (typeof value === 'boolean') return 'boolean'; //si un bool

    //si un tableau
    if (Array.isArray(value)) {
        const first = value[0];
        //si valeur presente verifie sont type
        if (first !== undefined && first !== null) {
            //si tableau d'object refait un schema de l'object
            if (typeof first === 'object' && !Array.isArray(first)) {
                return [detectType(first) as Schema];
            }
            else {
                //obtien de le type de l'elment
                return [detectType(first) as SchemaType];
            }
        }
        else {
            //pas defini
            return ['undefined'];
        }

    }

    //si s'est un object et pas null
    if (typeof value === 'object' && value !== null) {
        //fait un schema avec tout les type detecter
        const schema: Schema = {};
        Object.keys(value).forEach(key => {
            schema[key] = detectType(value[key]);
        })
        return schema;
    }

    return 'undefined'; // fallback
}

/**
 * fait un schema d'un object fournit
 * @param sample object a schematiser
 * @returns le schema creez
 */
function generateSchemaFromSample(sample: any): SchemaType | Schema {
    //si pas un object
    if (typeof sample !== 'object' || sample === null || Array.isArray(sample)) {
        return detectType(sample);
    }

    //si un object
    const schema: Schema = {};
    for (const key in sample) {
        //regarde le type pour chaque valeur du sample
        schema[key] = detectType(sample[key]);
    }
    return schema;
}


function validateValue(value: any, typeDesc: SchemaType | Schema): any {
    // log("----------", "type", typeDesc);
    // log("val", value, "----------");
    //si s'est un seul element
    if (typeof typeDesc === 'string') {
        switch (typeDesc) {
            case 'string': return typeof value === 'string' ? value : null;
            case 'number': return typeof value === 'number' ? value : null;
            case 'boolean': return typeof value === 'boolean' ? value : null;
            case 'undefined': return value;
            default: return null;
        }
    }
    //si s'est un array
    else if (Array.isArray(typeDesc)) {
        if (Array.isArray(value)) {
            const itemSchema = typeDesc[0];
            var result: any[] = [];

            value.forEach(element => {
                result.push(validateValue(element, itemSchema));
            });
            return result;
        }

    }
    //si s'est un object
    else if (typeof typeDesc === 'object') {
        const result: any = {};
        for (const key in typeDesc) {
            result[key] = validateValue(value?.[key], typeDesc[key]);
        }
        return result;
    }

    return null;
}

/**
 * prend des valeurs brut fournit et un patern avec l'object a obtenir au niveau des type et cree un object avec les valeurs valide
 * @param raw object brut
 * @param patern l'object schema
 * @returns renvoie un object contenant les valeurs de brut correct selon le patern
 */
export function validate<T>(raw: any, patern: any): T {
    //genere un schema
    const schema = generateSchemaFromSample(patern);
    // log(schema);
    //renvoie l'object avec les bonne valeur
    return validateValue(raw, schema) as T;
}
